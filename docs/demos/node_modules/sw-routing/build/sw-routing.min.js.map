{"version":3,"sources":["index.js"],"names":["global","factory","exports","module","define","amd","goog","routing","parse","str","options","res","tokens","key","index","path","defaultDelimiter","delimiter","PATH_REGEXP","exec","m","escaped","offset","slice","length","next","prefix","name","capture","group","modifier","asterisk","push","pattern","optional","repeat","partial","escapeGroup","escapeString","substr","encodeURIComponentPretty","encodeURI","replace","c","charCodeAt","toString","toUpperCase","encodeAsterisk","tokensToFunction","matches","Array","i","RegExp","obj","opts","data","encode","pretty","encodeURIComponent","token","segment","value","TypeError","isarray","JSON","stringify","j","test","attachKeys","re","keys","flags","sensitive","regexpToRegexp","groups","source","match","arrayToRegexp","parts","pathToRegexp","regexp","join","stringToRegexp","tokensToRegExp","strict","end","route","endsWithDelimiter","assert","atLeastOne","object","parameters","Object","some","parameter","Error","map","p","hasMethod","expectedMethod","pop","type","isInstance","expectedClass","isOneOf","values","includes","isType","expectedType","actualType","isSWEnv","self","ServiceWorkerGlobalScope","isValue","expectedValue","actualValue","validMethods","Route","constructor","handler","method","index$1","isArray","arr","prototype","call","compile","ExpressRoute","regExp","url","pathname","RegExpRoute","href","Router","setDefaultHandler","defaultHandler","setCatchHandler","catchHandler","registerRoutes","routes","addEventListener","event","URL","request","protocol","startsWith","responsePromise","matchResult","handle","params","catch","error","respondWith","registerRoute","defineProperty"],"mappings":"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","file":"sw-routing.min.js","sourcesContent":["(function (global, factory) {\n     typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n     typeof define === 'function' && define.amd ? define(['exports'], factory) :\n     (factory((global.goog = global.goog || {}, global.goog.routing = global.goog.routing || {})));\n}(this, (function (exports) { 'use strict';\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nfunction atLeastOne(object) {\n  const parameters = Object.keys(object);\n  if (!parameters.some(parameter => object[parameter] !== undefined)) {\n    throw Error('Please set at least one of the following parameters: ' + parameters.map(p => `'${ p }'`).join(', '));\n  }\n}\n\nfunction hasMethod(object, expectedMethod) {\n  const parameter = Object.keys(object).pop();\n  const type = typeof object[parameter][expectedMethod];\n  if (type !== 'function') {\n    throw Error(`The '${ parameter }' parameter must be an object that exposes ` + `a '${ expectedMethod }' method.`);\n  }\n}\n\nfunction isInstance(object, expectedClass) {\n  const parameter = Object.keys(object).pop();\n  if (!(object[parameter] instanceof expectedClass)) {\n    throw Error(`The '${ parameter }' parameter must be an instance of ` + `'${ expectedClass.name }'`);\n  }\n}\n\nfunction isOneOf(object, values) {\n  const parameter = Object.keys(object).pop();\n  if (!values.includes(object[parameter])) {\n    throw Error(`The '${ parameter }' parameter must be set to one of the ` + `following: ${ values }`);\n  }\n}\n\nfunction isType(object, expectedType) {\n  const parameter = Object.keys(object).pop();\n  const actualType = typeof object[parameter];\n  if (actualType !== expectedType) {\n    throw Error(`The '${ parameter }' parameter has the wrong type. ` + `(Expected: ${ expectedType }, actual: ${ actualType })`);\n  }\n}\n\nfunction isSWEnv() {\n  return 'ServiceWorkerGlobalScope' in self && self instanceof ServiceWorkerGlobalScope;\n}\n\nfunction isValue(object, expectedValue) {\n  const parameter = Object.keys(object).pop();\n  const actualValue = object[parameter];\n  if (actualValue !== expectedValue) {\n    throw Error(`The '${ parameter }' parameter has the wrong value. ` + `(Expected: ${ expectedValue }, actual: ${ actualValue })`);\n  }\n}\n\nvar assert = {\n  atLeastOne,\n  hasMethod,\n  isInstance,\n  isOneOf,\n  isType,\n  isSWEnv,\n  isValue\n};\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nconst defaultMethod = 'GET';\nconst validMethods = ['DELETE', 'GET', 'HEAD', 'POST', 'PUT'];\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * The Route class is used to configure a *when*\n * [predicate](https://en.wikipedia.org/wiki/Predicate_(mathematical_logic))\n * a handler.\n *\n * The *when* predicate is used by the Router to determine if a given request\n * matches this Route. If *when* returns true (i.e. this route matches the\n * current request), then the handler will be given the\n * [FetchEvent](https://developer.mozilla.org/en-US/docs/Web/API/FetchEvent)\n * so that it can respond to the request.\n *\n * @memberof module:sw-routing\n */\nclass Route {\n  /**\n   * The constructor for Route expects an object with `when` and `handler`\n   * properties which should both be functions.\n   * @param {Object} options - Options to initialize the Route with.\n   * @param {function} options.when - The when predicate function.\n   * @param {function} options.handler - The handler function that will respond\n   * to a FetchEvent.\n   */\n  constructor({ match, handler, method } = {}) {\n    assert.isType({ match }, 'function');\n    assert.hasMethod({ handler }, 'handle');\n\n    this.match = match;\n    this.handler = handler;\n    if (method) {\n      assert.isOneOf({ method }, validMethods);\n      this.method = method;\n    } else {\n      this.method = defaultMethod;\n    }\n  }\n}\n\nvar index$1 = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n\nvar isarray = index$1;\n\n/**\n * Expose `pathToRegexp`.\n */\nvar index = pathToRegexp;\nvar parse_1 = parse;\nvar compile_1 = compile;\nvar tokensToFunction_1 = tokensToFunction;\nvar tokensToRegExp_1 = tokensToRegExp;\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g');\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = [];\n  var key = 0;\n  var index = 0;\n  var path = '';\n  var defaultDelimiter = options && options.delimiter || '/';\n  var res;\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0];\n    var escaped = res[1];\n    var offset = res.index;\n    path += str.slice(index, offset);\n    index = offset + m.length;\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1];\n      continue\n    }\n\n    var next = str[index];\n    var prefix = res[2];\n    var name = res[3];\n    var capture = res[4];\n    var group = res[5];\n    var modifier = res[6];\n    var asterisk = res[7];\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path);\n      path = '';\n    }\n\n    var partial = prefix != null && next != null && next !== prefix;\n    var repeat = modifier === '+' || modifier === '*';\n    var optional = modifier === '?' || modifier === '*';\n    var delimiter = res[2] || defaultDelimiter;\n    var pattern = capture || group;\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    });\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index);\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path);\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length);\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$');\n    }\n  }\n\n  return function (obj, opts) {\n    var path = '';\n    var data = obj || {};\n    var options = opts || {};\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n\n      if (typeof token === 'string') {\n        path += token;\n\n        continue\n      }\n\n      var value = data[token.name];\n      var segment;\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix;\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j]);\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment;\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value);\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment;\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys;\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g);\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      });\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = [];\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source);\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  var strict = options.strict;\n  var end = options.end !== false;\n  var route = '';\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n\n    if (typeof token === 'string') {\n      route += escapeString(token);\n    } else {\n      var prefix = escapeString(token.prefix);\n      var capture = '(?:' + token.pattern + ')';\n\n      keys.push(token);\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*';\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?';\n        } else {\n          capture = prefix + '(' + capture + ')?';\n        }\n      } else {\n        capture = prefix + '(' + capture + ')';\n      }\n\n      route += capture;\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/');\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?';\n  }\n\n  if (end) {\n    route += '$';\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)';\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options);\n    keys = [];\n  }\n\n  options = options || {};\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n\nindex.parse = parse_1;\nindex.compile = compile_1;\nindex.tokensToFunction = tokensToFunction_1;\nindex.tokensToRegExp = tokensToRegExp_1;\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * ExpressRoute is a helper class to make defining Express-style\n * [Routes]{@link Route} easy.\n *\n * Under the hood, it uses the [`path-to-regexp`](https://www.npmjs.com/package/path-to-regexp)\n * library to transform the `path` parameter into a regular expression, which is\n * then matched against the URL's path.\n *\n * @memberof module:sw-routing\n * @extends Route\n */\nclass ExpressRoute extends Route {\n  /**\n   * @param {string} path The path to use for routing.\n   * @param {function} handler The handler to manage the response.\n   */\n  constructor({ path, handler, method }) {\n    assert.isType({ path }, 'string');\n    assert.hasMethod({ handler }, 'handle');\n\n    const regExp = index(path);\n    const match = ({ url }) => url.pathname.match(regExp);\n    super({ match, handler, method });\n  }\n}\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * RegExpRoute is a helper class to make defining Regular Expression based\n * [Routes]{@link Route} easy.\n *\n * @memberof module:sw-routing\n * @extends Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * @param {RegExp} regExp The regular expression to match against URL's.\n   * @param {function} handler The handler to manage the response.\n   */\n  constructor({ regExp, handler, method }) {\n    assert.isInstance({ regExp }, RegExp);\n    assert.hasMethod({ handler }, 'handle');\n\n    const match = ({ url }) => url.href.match(regExp);\n    super({ match, handler, method });\n  }\n}\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * The Router takes a set of {@link Route}'s and will direct fetch events\n * to those Route in the order they are registered.\n *\n * @memberof module:sw-routing\n */\nclass Router {\n  /**\n   * A default handler will have it's handle method called when a\n   * request doesn't have a matching route.\n   * @param {Object} input\n   * @param {Handler} input.handler A handler to deal with default routes.\n   */\n  setDefaultHandler({ handler } = {}) {\n    assert.hasMethod({ handler }, 'handle');\n\n    this.defaultHandler = handler;\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this catch handler\n   * will be called to return an error case.\n   * @param {Object} input\n   * @param {Handler} input.handler A handler to deal with errors in routes.\n   */\n  setCatchHandler({ handler } = {}) {\n    assert.hasMethod({ handler }, 'handle');\n\n    this.catchHandler = handler;\n  }\n\n  /**\n   * Register routes will take an array of Routes to register with the\n   * router.\n   *\n   * @param {Object} options\n   * @param {Array<Route>} options.routes\n   * @return {void}\n   */\n  registerRoutes({ routes } = {}) {\n    assert.isInstance({ routes }, Array);\n\n    self.addEventListener('fetch', event => {\n      const url = new URL(event.request.url);\n      if (!url.protocol.startsWith('http')) {\n        return;\n      }\n\n      let responsePromise;\n      for (let route of routes || []) {\n        if (route.method !== event.request.method) {\n          continue;\n        }\n\n        const matchResult = route.match({ url, event });\n        if (matchResult || matchResult === 0 || matchResult === '') {\n          responsePromise = route.handler.handle({\n            url,\n            event,\n            params: matchResult\n          });\n          break;\n        }\n      }\n\n      if (!responsePromise && this.defaultHandler) {\n        responsePromise = this.defaultHandler.handle({ url, event });\n      }\n\n      if (responsePromise && this.catchHandler) {\n        responsePromise = responsePromise.catch(error => {\n          return this.catchHandler.handle({ url, event, error });\n        });\n      }\n\n      if (responsePromise) {\n        event.respondWith(responsePromise);\n      }\n    });\n  }\n\n  /**\n   * Registers a route with the router.\n   * @param {Object} input\n   * @param {Route} input.route The route to register.\n   */\n  registerRoute({ route } = {}) {\n    assert.isInstance({ route }, Route);\n\n    this.registerRoutes({ routes: [route] });\n  }\n}\n\n/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\n/**\n * sw-routing Module\n * @module sw-routing\n */\n\nexports.ExpressRoute = ExpressRoute;\nexports.RegExpRoute = RegExpRoute;\nexports.Route = Route;\nexports.Router = Router;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"sourceRoot":"/source/"}